<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lyrics</title>
  <style>
    :root {
      --side-width: 400px;
      --side-padding: 16px;
    }

    html, body {
      font-size: 16px;
      margin: 0;
      padding: 0;
    }

    .side {
      position: fixed;
      top: 0;
      left: 0;
      width: var(--side-width);
      height: 100%;
      background-color: #f0f0f0;
      padding: 16px;
    }

    .mt-4 {
      margin-top: 16px;
    }

    #lrcArea {
      margin-left: calc(var(--side-width) + var(--side-padding) * 2);
      height: 1000px;
      padding: 0 16px;
    }
  </style>
</head>
<body>
  <div class="side">
    <div><span>lrc: </span><input id="lrc" type="file" name="lrc"></div>
    <div class="mt-4"><span>sound: </span><input id="sound" type="file" name="sound"></div>
    <div class="mt-4"><video id="soundVideo" controls width="400"></video></div>
  </div>

  <div id="lrcArea">

  </div>

  <script type="module">
    import { Lyrics } from './lyrics.js'
    import { Cursor } from './cursor.js'

    const lrcInput = document.getElementById('lrc')
    const soundInput = document.getElementById('sound')
    const soundVideo = document.getElementById('soundVideo')
    const lrcArea = document.getElementById('lrcArea')

    const decoder = new TextDecoder('shift-jis')
    const encoder = new TextEncoder('shift-jis')

    let lrc = null
    let lrcData = []
    let cursor = null
    let cursorTimer = 0
    let cursorBorder = false

    const unFilledBlockBorderStyle = '1px dashed gray'
    const filledBlockBorderStyle = '1px solid red'
    const cursorBlockBorderStyle = '2px solid blue'

    const getCursorElement = () => {
      const blockEl = lrcArea.children[cursor.row].children[cursor.col]
      if (lrc.data[cursor.row][cursor.col].ruby) {
        return blockEl.children[0].children[cursor.rubyIndex]
      } else {
        return blockEl
      }
    }

    const cursorCallback = () => {
      if (lrcData.length === 0) return
      cursorBorder = !cursorBorder
      getCursorElement().style.outline = cursorBorder
        ? cursorBlockBorderStyle
        : cursor.getBlock().time
          ? filledBlockBorderStyle
          : unFilledBlockBorderStyle
      cursorTimer = setTimeout(cursorCallback, 500)
    }

    soundInput.addEventListener('change', (e) => {
      if (soundVideo.src) {
        URL.revokeObjectURL(soundVideo.src)
      }
      const sound = e.target.files[0]
      soundVideo.src = URL.createObjectURL(sound)
    })

    lrcInput.addEventListener('change', (e) => {
      const reader = new FileReader()
      reader.onload = (e) => {
        const lrcText = decoder.decode(new Uint8Array(e.target.result))
        lrc = Lyrics.parse(lrcText)
        console.log(lrc)
        cursor = new Cursor(lrc, true)

        lrcData = lrc.data
        lrcArea.innerHTML = ''
        lrcData.forEach((line) => {
          const p = document.createElement('p')
          p.style.margin = '20px 0'
          p.style.fontSize = '24px'
          line.forEach((block, index) => {
            const blockElement = document.createElement('ruby')
            // blockElement.style.display = 'inline-block'
            // blockElement.style.height = '40px'
            blockElement.style.boxSizing = 'border-box'
            blockElement.style.padding = '24px 8px 8px 8px'
            blockElement.style.margin = '2px'
            blockElement.style.verticalAlign = 'bottom'
            blockElement.textContent = block.word
            p.appendChild(blockElement)

            blockElement.style.outline = block.time ? filledBlockBorderStyle : unFilledBlockBorderStyle

            if (block.ruby) {
              const rubyElement = document.createElement('rt')
              for (let i = 0; i < block.ruby.length; i++) {
                const rubyCharElement = document.createElement('span')
                rubyCharElement.style.display = 'inline-block'
                rubyCharElement.style.outline = unFilledBlockBorderStyle
                rubyCharElement.style.outline = block.ruby[i].time ? filledBlockBorderStyle : unFilledBlockBorderStyle
                rubyCharElement.style.boxSizing = 'border-box'
                rubyCharElement.style.padding = '1px'
                rubyCharElement.style.margin = '0 1px'
                rubyCharElement.style.position = 'relative'
                rubyCharElement.style.bottom = '2px'
                rubyCharElement.textContent = block.ruby[i].word
                rubyElement.appendChild(rubyCharElement)
              }
              blockElement.appendChild(rubyElement)
            }
          })
          lrcArea.appendChild(p)
        })

        clearTimeout(cursorTimer)
        cursorCallback()
      }
      reader.readAsArrayBuffer(e.target.files[0])
    })

    const isVideoPlaying = video => Boolean(video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2);

    document.addEventListener('keydown', (e) => {
      console.log(e.key)
      if (e.key === 'ArrowRight') {
        e.preventDefault()
        const el = getCursorElement()
        el.style.outline = cursor.getBlock().time
          ? filledBlockBorderStyle
          : unFilledBlockBorderStyle
        cursor.right()
        cursorBorder = false
        clearTimeout(cursorTimer)
        cursorCallback()
      } else if (e.key === 'ArrowLeft') {
        e.preventDefault()
        const el = getCursorElement()
        // if (!isVideoPlaying(soundVideo) || lrcData.length === 0) return
        el.style.outline = cursor.getBlock().time
          ? filledBlockBorderStyle
          : unFilledBlockBorderStyle
        if (cursor.left()) {
          // el.style.color = ''
          // el.style.outline = unFilledBlockBorderStyle
          // soundVideo.currentTime = lrcData[cursor.row][cursor.col].time - 1
          // delete lrcData[cursor.row][cursor.col].time
        }
        cursorBorder = false
        clearTimeout(cursorTimer)
        cursorCallback()
      } else if (e.key === 'ArrowDown') {
        e.preventDefault()
        const el = getCursorElement()
        el.style.outline = cursor.getBlock().time
          ? filledBlockBorderStyle
          : unFilledBlockBorderStyle
        cursor.down()
        cursorBorder = false
        clearTimeout(cursorTimer)
        cursorCallback()
      } else if (e.key === 'ArrowUp') {
        e.preventDefault()
        const el = getCursorElement()
        el.style.outline = cursor.getBlock().time
          ? filledBlockBorderStyle
          : unFilledBlockBorderStyle
        cursor.up()
        cursorBorder = false
        clearTimeout(cursorTimer)
        cursorCallback()
      } else if (e.key === ' ') {
        e.preventDefault()
        if (!isVideoPlaying(soundVideo) || lrcData.length === 0) return
        const el = getCursorElement()
        // TODO: fix this
        const currentTime = soundVideo.currentTime
        el.style.color = 'red'
        el.style.outline = filledBlockBorderStyle
        cursor.getBlock().time = currentTime
        el.style.outline = cursor.getBlock().time
          ? filledBlockBorderStyle
          : unFilledBlockBorderStyle
        cursor.right()
        cursorBorder = false
        clearTimeout(cursorTimer)
        cursorCallback()
      } else if (e.key === 'Enter') {
        console.log(lrc.toString())
      }
    })
  </script>
</body>
</html>
